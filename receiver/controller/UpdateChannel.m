function [channel]= UpdateChannel(channel, syst, PRN, status)

global GSAR_CONSTANTS;

% First, empty multipath structs
channel.PLL(2:end) = [];
channel.DLL(2:end) = [];
channel.ALL(2:end) = [];

switch syst
    case 'BD_B1I'
        channel.CH_B1I(2:end) = [];
    case 'GPS_L1CA'
        channel.CH_L1CA(2:end) = [];
end

% Empty loop filter register
channel.PLL.Fn             = 3;                                  % FLL noise bandwidth, [Hz]
channel.PLL.REG            = zeros(4,1);                         % Filter registers
channel.PLL.IQ_d           = zeros(2,1);                         % Storing previous prompt I,Q channel cumulative values
channel.PLL.freqbin_reg_I  = zeros(channel.PLL.fllopen_binum, 1);
channel.PLL.freqbin_reg_Q  = zeros(channel.PLL.fllopen_binum, 1);

channel.DLL.REG            = zeros(4,1);                         % Filter registers

channel.ALL.An             = 5;                                  % ALL noise bandwidth, [Hz]
channel.ALL.AFn            = 0.5;                                % AFL noise bandwidth, [Hz]
channel.ALL.ai_v           = zeros(4,1);                         % I channel amplitude estimates
channel.ALL.ai_reg         = zeros(4,1);                         % I channel regs
channel.ALL.ai_freg        = zeros(4,1);                         % I channel freq regs
channel.ALL.aq_v           = zeros(4,1);                         % Q channel amplitude estimates
channel.ALL.aq_reg         = zeros(4,1);                         % Q channel regs
channel.ALL.aq_freg        = zeros(4,1);                         % Q channel freq regs
channel.ALL.NormSampN      = 0;                                  % The Counter used for normalizing the estimated amplitude of the singal
channel.ALL.TslotNormSampN = 0;                                  % The normalizing factor in a Tslot
channel.ALL.a_avg          = zeros(4,1);                         % 
channel.ALL.a_std          = zeros(3,1);                         % 
channel.ALL.acnt           = 0;                                  % SNR estimation counter
channel.ALL.SNR            = 0;

% Here, VTL kalman prefilter structure need a reset
STR_KalPreFilt.loopErrState = [0, 0, 0, 0]';
STR_KalPreFilt.P0 = [0.25, 1, 500, 10]';% diagnal values
STR_KalPreFilt.P  = zeros(4,4); % estimation error covariance
STR_KalPreFilt.Q  = [1e-2, 1e-3, 1e-2, 10]';% state process variance
STR_KalPreFilt.R  = [0.1, 0.1]';% measurement error variance
STR_KalPreFilt.firstFiltering = int32(1);% flag indicating first loop filtering
channel.KalPreFilt(2:end) = [];
channel.KalPreFilt = STR_KalPreFilt;

% CN0 estimator structure initialization
STR_CN0_Estimator = struct(...
    'CN0EstActive',          0, ... % CN0 estimation enable,1->On; 0->Off.
    'muavg_T',               1, ... % the time needed for computing a CN0, 1s by default
    'mupool_NMax',           [],... % The depth of mu memory pool
    'muk_cnt',               0, ... % mu memory pool counter
    'mu_avg',                0, ... % the computed average mu(NBP/WBP)
    'CN0',                   0, ... % the estimated CN0
    'WideB_Pw_IQ',           zeros(2,1), ...% wide-band correlators
    'NarrowB_Pw_IQ',         zeros(2,1)  ...% narrow-band correlators
); % 8

STR_CorrM_Bank = struct(...
    'corrM_Spacing',         2, ...%spacing of bank of M Correlators in samples
    'corrM_Num',             [],...%the total number of the correlator bank, eg. M
    'corrM_I_vt',            [],...%mem vectors storing I channels' correlations
    'corrM_Q_vt',            [],...%mem vectors storing Q channels' correlations
    'uncancelled_corrM_I_vt',[],...
    'uncancelled_corrM_Q_vt',[],...
    'normRx_I_vt',           [],...% normalized correlation function Rx of the Unit, I channel
    'normRx_Q_vt',           [],...% Q channel
    'normRx_vt',             [],...% I^2 + Q^2
    ...%The following four variables recording the latest correlation shaps
    'corrM_I_vt_Save',       [],...
    'corrM_Q_vt_Save',       [],...
    'uncancelled_corrM_I_vt_Save',   [],...
    'uncancelled_corrM_Q_vt_Save',   []...
);%13


switch syst
    case 'BD_B1I'
        % BDS B1 receiver channel structure initialization
        channel.CH_B1I = struct( ...
            'CH_STATUS',             status, ...
            'PRNID',                 PRN, ...%
            'navType',               [], ...%type of navigation message ('B1I_D1','B1I_D2')
            'codeTable',             [], ...
            'LO2_CarPhs',            0 + 0.25, ...%0
            'LO2_IF0',               GSAR_CONSTANTS.STR_RECV.IF, ...%
            'LO2_fd',                0, ...%1200
            'LO2_framp',             0, ...%
            'LO2_fjerk',             0, ...%
            'LO_CodPhs',             0.0,...%
            'LO_Fcode0',             GSAR_CONSTANTS.STR_B1I.Fcode0, ...%
            'LO_Fcode_fd',           0/763,...
            'Tcohn_cnt',             0, ...%
            ...Define information frame format
            'WN',                    0,                 ...Week number counter
            'SOW',                   0,                 ...Second number counter of current subframe beginning in a week
            'Frame_N',               0,                 ...Frame counter, 0~23 for D1, 0~119 for D2
            'SubFrame_N',            0,                 ...Frame counter, 0~4
            'Word_N',                0,                 ...word counter,0~9
            'Bit_N',                 0,                 ...navigation bit counter in a word,0~29       
            'T1ms_N',                0,                 ...PRN period counter in a bit, 0~19 for D1, 0~1 for D2
            ...%Define the track parameters and registers
            'Trk_Count',             0, ...%
            'Tcohn_N',               [], ...%number of 1ms, equivalent to the coherent tracking time
                                        ...%recommanded value: 20/n where n is an positive integer
            'Tslot_I',               zeros(3,1), ...%channel I 1ms correlators, [early,prompt,late]
            'Tslot_Q',               zeros(3,1), ...%channel Q 1ms correlators, [early,prompt,late]
            'T_I',                   zeros(3,1), ...%channel I Tms correlators, [early,prompt,late]
            'T_Q',                   zeros(3,1), ...%channel Q Tms correlators, [early,prompt,late]
            'T_pll_I',               zeros(3,1), ...%the I channel Tms correlations that correlates the 
                                                 ...%composite signal without cancellatin; it will be 
                                                 ...%used only for carrier PLL loop;
            'T_pll_Q',               zeros(3,1), ...
            'PromptIQ_D',            zeros(2,1), ...%delay values of I,Q channels' prompt correlator
                                                 ...%[Prompt_I_D, Prompt_Q_D]
            ...%Define the CNR-computing parameters
            'CN0_Estimator',         STR_CN0_Estimator,  ...% B1I channel CN0 estimator structure
            ...'PTslot_I_vt',           zeros(GSAR_CONSTANTS.STR_B1I.NT1ms_in_D1,1), ...%1KHz wideband I accumulator values
            ...'PTslot_Q_vt',           zeros(GSAR_CONSTANTS.STR_B1I.NT1ms_in_D1,1), ...%1KHz wideband Q accumulator values
            ...'muavg_T',               1,  ...%the time needed for computing a CN0, 1s by default
            ...'mupool_NMax',           [], ...% The depth of mu memory pool
            ...'muk_cnt',               0, ...%mu memory pool counter
            ...'mu_avg',                0, ...%the computed average mu(NBP/WBP)
            ...'CN0',                   0, ...%the estimated CN0
            ...'CN0EstActive',          0, ...%CN0 estimation enable,1->On; 0->Off.
            ...'SNR',                   0, ...%the estimated SNR
            'Samp_Posi',             0, ...%0~N-1
            'sigma',                 0, ...%channel pll discriminator output's variance estimates
            'sigma_checkT',          1, ...%[s]
            'sigma_checkNMax',       [],...
            'sigma_checkTimer',      0, ...
            'sigma_warningCnt',      0, ...
            'sigmaThrelol',          0.015,...
            ...%Mems for recording the correlation shape of current Unit
            'CorrM_Bank',            STR_CorrM_Bank, ...
            ...'corrM_Spacing',         2, ...%spacing of bank of M Correlators in samples
            ...'corrM_Num',             [],...%the total number of the correlator bank, eg. M
            ...'corrM_I_vt',            [],...%mem vectors storing I channels' correlations
            ...'corrM_Q_vt',            [],...%mem vectors storing Q channels' correlations
            ...'uncancelled_corrM_I_vt',[],...
            ...'uncancelled_corrM_Q_vt',[],...
            ...'normRx_I_vt',           [],...% normalized correlation function Rx of the Unit, I channel
            ...'normRx_Q_vt',           [],...% Q channel
            ...'normRx_vt',             [],...% I^2 + Q^2
            ...
            'SFNav',                 zeros(10,1), ...
            'SFNav_prev',            zeros(10,1), ...
            'Bit_Inv',               0, ... % 1 means the nav bit should be inverted
            'SF_Complete',           0, ... % Flag whether a subframe is complete
            'Frame_Sync',            'NOT_FOUND', ...
            'state1',                0, ...
            'state2',                0, ...
            ...
            'carrPhaseAccum',        0, ... % Accumulation of carrier phase variation due to doppler frequency
            'ephReady',              0, ... % Flag whether ephemeris is demodulated completely, 1 for yes, 0 for not yet (just in MATLAB)
            'bitDetect',             0  ... % detect whether nav bit is correct
        );  % 50

        channel.CH_B1I.acq = struct(... % Acquisition struct
            'STATUS',                'strong',...  %strong/weak
            'TC',                    0, ...
            'L0Fc0_R',               0, ...
            'IF0',                   0, ...
            'freqSearch',            0, ...
            'freqBin',               0, ...
            'freqOrder',             [], ...
            'sampPerTC_s',           0, ...
            'sampPer2TC_s',          0, ...
            'skipNumberOfCodes',     [], ...
            'accum',                 0, ...
            'acqID',                 0,...      % 判断是否完成捕获
            'resiData',              [],...     % 剩余数据采样点
            'resiN',                0,...           % resiData的数据长度
            'acqResults',            [],...
            'corr',                  [] ...
        );
        channel.CH_B1I.acq.acqResults = struct(...
            'sv',            0,...
            'acqed',         0,...
            'corr',          0,...
            'corrpeak',      0,...
            'freqOrder',     0,...
            'samps',         0,...
            'freqIdx',       0,...
            'codeIdx',       0,...
            'nc',            0,...
            'snr',           0,...
            'doppler',       0,...
            'RcFsratio',     0 ...
        );
        channel.CH_B1I.bitSync = struct(... % bitSync struct
            'STATUS',                'strong',...  %strong/weak
            'waitNum',               0, ...        % 等待采样点数
            'TC',                    0, ...
            'nhCode',                [], ...
            'nhLength',              0, ...
            'frange',                0, ...
            'fbin',                  0, ...
            'fnum',                  0, ...
            'Fcodesearch',           0, ...
            'sampPerCode',           0, ...
            'skipNumberOfSamples',   0, ...
            'skipNperCode',          0, ...
            'accum',                 0, ...
            'resiData',              [],...
            'resiN',                0,...           % resiData的数据长度
            'carriPhase',            0,  ...
            'Samp_Posi_dot',         0,...
            'offCarri',             [],...
            'bitSyncResults',       [],...
            'bitSyncID',            0,...
            'corr',                  [], ...
            'corrtmp',               [] ...
        );
        channel.CH_B1I.bitSync.bitSyncResults = struct(...
            'sv',            0,...
            'synced',        0,...
            'nc_corr',       0,...
            'freqIdx',       0,...
            'bitIdx',        0,...
            'doppler',       0 ...
        );
        if channel.CH_B1I.PRNID > 5
            channel.CH_B1I.navType = 'B1I_D1';
            channel.CH_B1I.Tcohn_N = 10; % D1 signal: maximal integration time 20ms    
        else
            channel.CH_B1I.navType = 'B1I_D2';
            channel.CH_B1I.Bit_N = floor(channel.CH_B1I.T1ms_N/GSAR_CONSTANTS.STR_B1I.NT1ms_in_D2);
            channel.CH_B1I.T1ms_N = mod(channel.CH_B1I.T1ms_N, GSAR_CONSTANTS.STR_B1I.NT1ms_in_D2);
            channel.CH_B1I.Tcohn_N = 2; % D2 signal: maximal integration time 2ms
        end
        
        channel.CH_B1I.Tcohn_cnt = mod(channel.CH_B1I.T1ms_N, channel.CH_B1I.Tcohn_N);

        channel.CH_B1I.CN0_Estimator.mupool_NMax = round(channel.CH_B1I.CN0_Estimator.muavg_T*1e3);
        channel.CH_B1I.sigma_checkNMax = round(channel.CH_B1I.sigma_checkT*1e3 / channel.CH_B1I.Tcohn_N);
        
        channel.CH_B1I.CorrM_Bank.corrM_Num = 1 + 2*round(2 * GSAR_CONSTANTS.STR_RECV.fs / GSAR_CONSTANTS.STR_B1I.Fcode0 / channel.CH_B1I.CorrM_Bank.corrM_Spacing);
        channel.CH_B1I.CorrM_Bank.corrM_I_vt = zeros(channel.CH_B1I.CorrM_Bank.corrM_Num, 1);
        channel.CH_B1I.CorrM_Bank.corrM_Q_vt = zeros(channel.CH_B1I.CorrM_Bank.corrM_Num, 1);
        channel.CH_B1I.CorrM_Bank.uncancelled_corrM_I_vt = zeros(channel.CH_B1I.CorrM_Bank.corrM_Num, 1);
        channel.CH_B1I.CorrM_Bank.uncancelled_corrM_Q_vt = zeros(channel.CH_B1I.CorrM_Bank.corrM_Num, 1);
        channel.CH_B1I.CorrM_Bank.normRx_I_vt = zeros(channel.CH_B1I.CorrM_Bank.corrM_Num, 1);
        channel.CH_B1I.CorrM_Bank.normRx_Q_vt = zeros(channel.CH_B1I.CorrM_Bank.corrM_Num, 1);
        channel.CH_B1I.CorrM_Bank.normRx_vt = zeros(channel.CH_B1I.CorrM_Bank.corrM_Num, 1);
        
        channel.CH_B1I.CorrM_Bank.corrM_I_vt_Save = zeros(channel.CH_B1I.CorrM_Bank.corrM_Num, 1);
        channel.CH_B1I.CorrM_Bank.corrM_Q_vt_Save = zeros(channel.CH_B1I.CorrM_Bank.corrM_Num, 1);
        channel.CH_B1I.CorrM_Bank.uncancelled_corrM_I_vt_Save = zeros(channel.CH_B1I.CorrM_Bank.corrM_Num, 1);
        channel.CH_B1I.CorrM_Bank.uncancelled_corrM_Q_vt_Save = zeros(channel.CH_B1I.CorrM_Bank.corrM_Num, 1);

    case 'GPS_L1CA'
        % GPS L1CA receiver channel structure definition
        channel.CH_L1CA = struct(...%
            'CH_STATUS',             status,...
            'PRNID',                 PRN,  ...%
            'codeTable',             [], ...
            'LO2_CarPhs',            0 + 0.25, ...%0
            'LO2_IF0',               GSAR_CONSTANTS.STR_RECV.IF, ...%
            'LO2_fd',                0, ...%1200
            'LO2_framp',             0, ...%
            'LO2_fjerk',             0, ...%
            'LO_CodPhs',             0.0,...%
            'LO_Fcode0',             GSAR_CONSTANTS.STR_L1CA.Fcode0, ...%
            'LO_Fcode_fd',           0/763,...
            'Tcohn_cnt',             0, ...%
            ...Define information frame format
            'WN',                    0,                 ...Week number counter
            'TOW_6SEC',                   0,                 ...Second number counter of current subframe beginning in a week
            'SubFrame_N',            0,                 ...Frame counter, 0~4
            'Word_N',                0,                 ...word counter,0~9
            'Bit_N',                 0,                 ...navigation bit counter in a word,0~29       
            'T1ms_N',                0,                 ...PRN period counter in a bit, 0~19 for D1, 0~1 for D2
            ...%Define the track parameters and registers
            'Trk_Count',             0, ...%
            'Tcohn_N',               10, ...%number of 1ms, equivalent to the coherent tracking time
                                        ...%recommanded value: 20/n where n is an positive integer
            'Tslot_I',               zeros(3,1), ...%channel I 1ms correlators, [early,prompt,late]
            'Tslot_Q',               zeros(3,1), ...%channel Q 1ms correlators, [early,prompt,late]
            'T_I',                   zeros(3,1), ...%channel I Tms correlators, [early,prompt,late]
            'T_Q',                   zeros(3,1), ...%channel Q Tms correlators, [early,prompt,late]
            'T_pll_I',               zeros(3,1), ...
            'T_pll_Q',               zeros(3,1), ...
            'PromptIQ_D',            zeros(2,1), ...%delay values of I,Q channels' prompt correlator
                                                 ...%[Prompt_I_D, Prompt_Q_D]
            ...%Define the CNR-computing parameters
            ...'PTslot_I_vt',           zeros(GSAR_CONSTANTS.STR_B1I.NT1ms_in_D1,1), ...%1KHz wideband I accumulator values
            ...'PTslot_Q_vt',           zeros(GSAR_CONSTANTS.STR_B1I.NT1ms_in_D1,1), ...%1KHz wideband Q accumulator values
            ...'muavg_T',               1,  ...%the time needed for computing a CN0, 1s by default
            ...'mupool_NMax',           [], ...% The depth of mu memory pool
            ...'muk_cnt',               0, ...%mu memory pool counter
            ...'mu_avg',                0, ...%the computed average mu(NBP/WBP)
            ...'CN0',                   0, ...%the estimated CN0
            ...'CN0EstActive',          0, ...%CN0 estimation enable,1->On; 0->Off.
            'CN0_Estimator',         STR_CN0_Estimator, ...
            'Samp_Posi',             0, ...%0~N-1
            'sigma',                 0, ...%channel pll discriminator output's variance estimates
            ...%Mems for recording the correlation shape of current Unit
            'CorrM_Bank',            STR_CorrM_Bank, ...
            ...'corrM_Spacing',         2, ...%spacing of bank of M Correlators in samples
            ...'corrM_Num',             [],...%the total number of the correlator bank, eg. M
            ...'corrM_I_vt',            [],...%mem vectors storing I channels' correlations
            ...'corrM_Q_vt',            [],...%mem vectors storing Q channels' correlations
            ...'uncancelled_corrM_I_vt',[],...
            ...'uncancelled_corrM_Q_vt',[],...
            ...'normRx_I_vt',           [],...
            ...'normRx_Q_vt',           [],...
            ...'normRx_vt',             [],...
            ...
            'SFNav',                 zeros(10,1), ...
            'SFNav_prev',            zeros(10,1), ...
            'Bit_Inv',               0, ... % 1 means the nav bit should be inverted
            'SF_Complete',           0, ... % Flag whether a subframe is complete
            'Frame_Sync',            'NOT_FOUND', ...
            'state1',                0, ...
            'state2',                0, ...
            ...
            'carrPhaseAccum',        0, ... % Accumulation of carrier phase variation due to doppler frequency
            'ephReady',              0, ... % Flag whether ephemeris is demodulated completely, 1 for yes, 0 for not yet (just in MATLAB)
            'last_twobits',          [],... % the last two bits of previous code
            'bitDetect',             0  ... % detect whether nav bit is correct
        );  % 46

        channel.CH_L1CA.acq = struct(... % Acquisition struct
            'STATUS',                'strong',...  %strong/weak
            'TC',                    0, ...
            'L0Fc0_R',               0, ...
            'IF0',                   0, ...
            'freqSearch',            0, ...
            'freqBin',               0, ...
            'freqOrder',             [], ...
            'sampPerTC_s',           0, ...
            'sampPer2TC_s',          0, ...
            'skipNumberOfCodes',     [], ...
            'accum',                 0, ...
            'acqID',                 0,...      % 判断是否完成捕获
            'resiData',              [],...     % 剩余数据采样点
            'resiN',                0,...           % resiData的数据长度
            'acqResults',            [],...
            'corr',                  [] ...
        );
        channel.CH_L1CA.acq.acqResults = struct(...
            'sv',            0,...
            'acqed',         0,...
            'corr',          0,...
            'corrpeak',      0,...
            'freqOrder',     0,...
            'samps',         0,...
            'freqIdx',       0,...
            'codeIdx',       0,...
            'nc',            0,...
            'snr',           0,...
            'doppler',       0,...
            'RcFsratio',     0 ...
        );
        channel.CH_L1CA.bitSync = struct(... % bitSync struct
            'STATUS',                'strong',...  %strong/weak
            'TC',                    0, ...
            'nhCode',                [], ...
            'nhLength',              0, ...
            'frange',                0, ...
            'fbin',                  0, ...
            'fnum',                  0, ...
            'Fcodesearch',           0, ...
            'sampPerCode',           0, ...
            'skipNumberOfSamples',   0, ...
            'skipNperCode',          0, ...
            'accum',                 0, ...
            'resiData',              [],...
            'resiN',                0,...           % resiData的数据长度
            'carriPhase',            0,  ...
            'Samp_Posi_dot',         0,...
            'offCarri',             [],...
            'bitSyncResults',       [],...
            'bitSyncID',            0,...
            'corr',                  [], ...
            'corrtmp',              [] ...
        );
        channel.CH_L1CA.bitSync.bitSyncResults = struct(...
            'sv',            0,...
            'synced',        0,...
            'nc_corr',       0,...
            'freqIdx',       0,...
            'bitIdx',        0,...
            'doppler',       0 ...
        );
        channel.CH_L1CA.Tcohn_cnt = mod(channel.CH_L1CA.T1ms_N, channel.CH_L1CA.Tcohn_N);

        channel.CH_L1CA.CN0_Estimator.mupool_NMax = round(channel.CH_L1CA.CN0_Estimator.muavg_T*1e3);

        channel.CH_L1CA.CorrM_Bank.corrM_Num = 1 + 2*round(2 * GSAR_CONSTANTS.STR_RECV.fs / GSAR_CONSTANTS.STR_L1CA.Fcode0 / channel.CH_L1CA.CorrM_Bank.corrM_Spacing);
        channel.CH_L1CA.CorrM_Bank.corrM_I_vt = zeros(channel.CH_L1CA.CorrM_Bank.corrM_Num, 1);
        channel.CH_L1CA.CorrM_Bank.corrM_Q_vt = zeros(channel.CH_L1CA.CorrM_Bank.corrM_Num, 1);
        channel.CH_L1CA.CorrM_Bank.uncancelled_corrM_I_vt = zeros(channel.CH_L1CA.CorrM_Bank.corrM_Num, 1);
        channel.CH_L1CA.CorrM_Bank.uncancelled_corrM_Q_vt = zeros(channel.CH_L1CA.CorrM_Bank.corrM_Num, 1);
        channel.CH_L1CA.CorrM_Bank.normRx_I_vt = zeros(channel.CH_L1CA.CorrM_Bank.corrM_Num, 1);
        channel.CH_L1CA.CorrM_Bank.normRx_Q_vt = zeros(channel.CH_L1CA.CorrM_Bank.corrM_Num, 1);
        channel.CH_L1CA.CorrM_Bank.normRx_vt = zeros(channel.CH_L1CA.CorrM_Bank.corrM_Num, 1);
        
        channel.CH_L1CA.CorrM_Bank.corrM_I_vt_Save = zeros(channel.CH_L1CA.CorrM_Bank.corrM_Num, 1);
        channel.CH_L1CA.CorrM_Bank.corrM_Q_vt_Save = zeros(channel.CH_L1CA.CorrM_Bank.corrM_Num, 1);
        channel.CH_L1CA.CorrM_Bank.uncancelled_corrM_I_vt_Save = zeros(channel.CH_L1CA.CorrM_Bank.corrM_Num, 1);
        channel.CH_L1CA.CorrM_Bank.uncancelled_corrM_Q_vt_Save = zeros(channel.CH_L1CA.CorrM_Bank.corrM_Num, 1);
end


% the CADLL Control Structure
channel.STR_CAD.CAD_STATUS = 'CAD_TRACK';   % CAD_TRACK/NEWMP_LOOKFOR/TRANSIENT
channel.STR_CAD.CadCnt     = channel.STR_CAD.CadLoop_NMAX;
channel.STR_CAD.CadUnit_N  = 1;             % define current number of units;
channel.STR_CAD.Moni_N     = 0;             % Monitor counter, counting from 0~MoniNMax-1, counting at a rate of 1kHz

% Computing the code phase lag between two adjacent units
channel.STR_CAD.CodPhsDiff_Avg = zeros(channel.STR_CAD.CadUnitMax,1); % zeros(channel.STR_CAD.CadUnitMax-1,1) ??? the last element is empty
channel.STR_CAD.CodPhsDiff_Avg_prev = zeros(channel.STR_CAD.CadUnitMax,1); %Store the previous CodPhsDiff_Avg
% Computing the normalized average amplitude of a signal component during one monitoring time
channel.STR_CAD.A_Avg = zeros(channel.STR_CAD.CadUnitMax,1);
% Compute the normalized amplitude stadard deviation of a signal component during one monitoring
% time.
channel.STR_CAD.A_Std = zeros(channel.STR_CAD.CadUnitMax,1);
% Allocate the tang registers for counting the number of errors of each unit
channel.STR_CAD.UnitErrTang_N = int32(zeros(channel.STR_CAD.CadUnitMax,1));

%***** Define some parameters regarding detecting a new MP *****
% The checking point of a new multipath in the CADLL chain, also called the inserted point. The new 
% unit will be inserted between InsrtNo~InsrtNo+1, so InsrtNo will be 0~CadUnit_N-1.
channel.STR_CAD.InsrtNo = 0;
channel.STR_CAD.CadCH_L1CA_Tr = channel.CH_L1CA; % Trail CH for L1CA signal in cadll detecting a new multipath
channel.STR_CAD.CadCH_B1I_Tr = channel.CH_B1I; % Trail CH for B1I signal in cadll detecting a new multipath
channel.STR_CAD.CadDLL_Tr    = channel.DLL;    % Trail CH's DLL structure
channel.STR_CAD.CadALL_Tr    = channel.ALL;    % Trail CH's ALL structure


channel.STR_CAD.TrCodphsDiff_Avg = 0;
channel.STR_CAD.TrChkSum_Errcode = uint32(0);  % CH_Tr checksum error code
channel.STR_CAD.Codfreq_Proj_Tr_ErrTang = 0;


channel.CH_ns = struct(...
    'Codphs_ns',               0,             ...% noise channle's code phase
    'Tslot_ns_IQ',             zeros(2,1),    ...% 1ms correlations of noise channel, I,Q channels
    'Avg_ns_IQ',               zeros(2,1),    ...% average over 1s, I,Q channels
    'Sq_ns_IQ',                zeros(2,1),    ...% average squares over 1s, I,Q channels
    'ns_Std',                  0,             ...% noise channel's std
    'NsCnt',                   0,             ...% noise channle counter
    'NormFactor',              0              ...% normalizing factor
);% 7




% Use initialization operations first
% channel = ChannelsInitializing(PRN);????

% Adjustment according to status
channel.STATUS = status;

switch syst
    case 'BD_B1I'
        channel.STR_CAD.CadCH_B1I_Tr.CH_STATUS = 'TRACK';
        channel.PLL.REG(1) = channel.CH_B1I.LO2_fd;
        channel.DLL.REG(1) = channel.CH_B1I.LO_Fcode_fd;
    case 'GPS_L1CA'
        channel.STR_CAD.CadCH_L1CA_Tr.CH_STATUS = 'TRACK';
        channel.PLL.REG(1) = channel.CH_L1CA.LO2_fd;
        channel.DLL.REG(1) = channel.CH_L1CA.LO_Fcode_fd;
end

end
